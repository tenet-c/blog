# 网络通信
## 通信的必要条件
- 主机之间需要传输介质
  (数据是以电信号传输故需要设备解析电信号,或光信号)
- 主机上必须要有网卡 将二进制转换成高低电压 或将高低电压解析成二进制 
- 主机之间需要协商网络速率
## 网络通信方式
  如何建立多台主机连接?
- 交换机通信
  所有主机通过交换机关联,但是A主机想发消息给B主机的时候,不知道B主机的地址,就将消息发给交换机,然后交换机广播给所有主机, B主机通过mac地址匹配(物理地址)接收消息,其他主机不匹配当初垃圾丢弃
  缺点:
      1.不适用于现代互联网 没有一个交换机是无限接口的
      2.局域网存在大量主机会造成广播封闭
- 路由器通信
  之后衍生出多个小型局域网
  发送数据会带上目标的网卡地址和目标网络ip地址 同时也会带上 本身的网卡地址和ip地址
  数据发送到对应的网络后 由交换机发送到对应的主机

## 网络层次模型
### OSI 七层模型
- 1.应用层: 用户对网络的接口 例如: http协议 网站服务  ftp协议文件传输服务 ssh远程登录服务
- 2.表示层: 数据加密 转换 压缩
- 3.会话层: 控制网络的建立和终止
- 4.传输层: 控制数据传输的可靠性 基于端口的协议层 数据封装的时候必须携带目标程序的端口号
- 5.网络层: 通过路由找到目标网络 常见的ip协议
- 6.数据链路层: 通过mac确定目标主机
- 7.物理层: 各种物理设备和标准
### TCP 四层
- 1.应用层 OSI的1.2.3层
- 2.主机层 OSI的4.5层
- 3.接入层 OSI的6层
- 4.物理层 OSI的7层
### 注
  发送时 数据会从上至下进行数据封装
  接收时 数据会从下至上进行分解

## 数据封装与解封
- 1.应用层
  数据data
- 2.传输层 
  TCP与UDP都是基于端口的 新增目标端口和源端口
  此时: 目标端口、源端口、数据data
- 3.网络层
  ip协议确认目标主机所在的网络 目标ip和源ip
  此时: 目标ip、源ip、目标端口、源端口、数据data
- 4.数据链路层
  封装时mac地址 目标mac和源mac
  最终: 目标mac、源mac、目标ip、源ip、目标端口、源端口、数据data

## TCP的三次握手与四次挥手
- TCP属于传输层
- TCP是面向连接的
- TCP处理实时通信
- TCP报文结构
头部:
16位源端口  |   16位目标端口
32位序列号
32位确认号
4位首部 | 保留 | 窗口
16位检验 | 紧急针
选项
数据:

常见控制字段:
- SYN = 1 表示请求建立连接
- FIN = 1 表示请求断开连接
- ACK = 1 表示数据信息确认

三次握手
一次握手: 客户端 发送SYN = 1 -> 服务端
二次握手: 服务端 发送ACK = 1 -> 客户端
三次握手: 服务端 发送SYN = 1 -> 客户端
四次握手: 客户端 发送ACK = 1 -> 服务端
优化: 二次握手和三次握手合并 服务端发送ACK 和 SYN 发送给客户端 变成三次握手

四次挥手
一次挥手: 客户端 发送FIN = 1 -> 服务端
二次挥手: 服务端 发送ACK = 1 -> 客户端
三次挥手: 服务端 发送FIN = 1 -> 客户端
四次挥手: 客户端 发送ACK = 1 -> 服务端
没有优化: 因为一个服务端服务多个客户端 当客户端发送断开连接的时候 服务端无法确认相对应的客户端的数据是否处理完 所以客户端和服务端分开挥手

### 总结
- TCP处于传输层的协议, 基于端口, 面向连接
- 主机之间想要连接需要建立双向通道
- TCP 挥手和握手本质都是四次 但是握手进行和合并 挥手没有合并

### 通信过程
- 创建服务端: 接收和回写客户端数据
- 创建客户端: 发送和接收服务端数据
- 数据传输: 内置服务事件和方法读写数据
#### 通信net事件
- listening: 调用server.listen 方法之后触发
- connection: 新的连接建立时触发
- close: 当server关闭时触发
- error: 当错误出现时触发
- data: 当接收到数据时触发
- write: 在socket上发送数据 默认UTF-8编码
- end: 当socket的一端发送FIN包时触发,结束可读端
ps:模拟tcp internet server.js 和 client.js

#### TCP数据粘包与解决
  基于流的操作 和 tcp的实现
  发送端会将数据进行处理之后再统一进行发送
  接收端也会将数据消费再回写
  就会造成粘包现象 就是多条发送粘成一条
  例:
    client.write(1)
    client.write(2)
    client.write(3)
    client.write(4)
  服务端应该受到1 2 3 4 四条数据 
  实际只收到一条 1234合并在了一起

##### 解决 
- 发送的时间间隔拉长 比如settimeout 
- 封包和拆包解决
###### 封包
- 1.进行数据编码,获取二进制数据包
- 2.按规则拆解数据,获取指定长度的数据
ps mytransfromCode.js

# http 协议
  目标解决 缓存 续存 断点续存 防盗链

## 什么是http协议
  http协议由两个部分组成
  - 请求
  - 响应
  具体信息看f12的network
  ps:创建个web服务 httpServer.js

### get与post请求
  ps get-request-info
  模拟post请求
  curl -v -X POST -d "'name':'chm'" http://localhost:1234/

### 设置http响应
  ps set-response-info

### 客户端代理
  ps:agent-server->agent-client
### 客户端代理(解决跨域)
  httpAgent
  ps:server -> client(代理) -> 浏览器

### http静态服务
  
